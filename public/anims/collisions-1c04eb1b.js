import{k as H,Y as F,Z as J,h as j,v as K,y as C,_ as Q,I as X,x as Z,$ as ee,B as se,z as te,D as ne,E as ae,G as ie,H as le,p as E,s as U,U as oe,u as q,M as R,m as re,j as w,a0 as f,K as V,e as c,a1 as ce,a as S,b as h,a2 as M,w as P,Q as A,c as k,N as pe,R as de,V as he,d as fe,f as ue}from"./makeScene2D-e3796321.js";import{C as ge}from"./Circle-f1bd054b.js";import{T as me}from"./Txt-a6815413.js";function ye(l,e,t){const s={arcLength:0,segments:[],minSin:1};if(l.length===0)return s;if(t){const a=l[0].add(l[l.length-1]).scale(.5);l=[a,...l,a]}let n=l[0];for(let a=2;a<l.length;a++){const o=l[a-2],r=l[a-1],g=l[a],v=o.sub(r),y=g.sub(r),d=v.normalized.safe,b=y.normalized.safe,I=Math.acos(H(-1,1,d.dot(b))),L=Math.tan(I/2),T=Math.sin(I/2),z=Math.min(e,L*v.magnitude*(a===2?1:.5),L*y.magnitude*(a===l.length-1?1:.5)),G=T===0?0:z/T,N=L===0?0:z/L,Y=d.add(b).scale(1/2).normalized.safe.scale(G).add(r),D=d.perpendicular.dot(b)<0,x=new F(n,r.add(d.scale(N))),B=new J(Y,z,d.perpendicular.scale(D?1:-1),b.perpendicular.scale(D?-1:1),D);x.arcLength>0&&(s.segments.push(x),s.arcLength+=x.arcLength),B.arcLength>0&&(s.segments.push(B),s.arcLength+=B.arcLength),s.minSin=Math.min(s.minSin,Math.abs(T)),n=r.add(b.scale(N))}const i=new F(n,l[l.length-1]);return i.arcLength>0&&(s.segments.push(i),s.arcLength+=i.arcLength),s}function be(l){return l.reduce((e,t,s)=>s?e+l[s-1].sub(t).magnitude:0,0)}function O(l,e,t){const s=l.length;let n=0;for(let i=0;i<e.length;i+=1){const a=l[(t+i)%s],o=e[i];n+=a.sub(o).squaredMagnitude}return n}function we(l,e,t){const s=[];if(t===0)return[...l];if(t===1)return[...e];for(let n=0;n<l.length;n++){const i=l[n],a=e[n];s.push(j.lerp(i,a,t))}return s}var m=globalThis&&globalThis.__decorate||function(l,e,t,s){var n=arguments.length,i=n<3?e:s===null?s=Object.getOwnPropertyDescriptor(e,t):s,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(l,e,t,s);else for(var o=l.length-1;o>=0;o--)(a=l[o])&&(i=(n<3?a(i):n>3?a(e,t,i):a(e,t))||i);return n>3&&i&&Object.defineProperty(e,t,i),i};class p extends K{static rotatePoints(e,t,s){if(s){let n=1/0,i=0;for(let a=0;a<e.length;a+=1){const o=O(e,t,a);o<n&&(n=o,i=a)}if(i){const a=e.splice(0,i);e.splice(e.length,0,...a)}}else{const n=O(e,t,0),i=[...e].reverse();O(i,t,0)<n&&e.reverse()}}static distributePoints(e,t){if(e.length===0){for(let o=0;o<t;o++)e.push(j.zero);return}if(e.length===1){const o=e[0];for(let r=0;r<t;r++)e.push(o);return}const s=e.length+t,n=be(e);let i=t/n,a=0;for(;e.length<s;){const o=s-e.length;if(a+1>=e.length){i=o/n,a=0;continue}const r=e[a],g=e[a+1],v=r.sub(g).magnitude,y=Math.min(Math.round(v*i),o)+1;for(let d=1;d<y;d++)e.splice(++a,0,j.lerp(r,g,d/y));a++}}*tweenPoints(e,t,s){const n=[...this.parsedPoints()],i=this.parsePoints(C(e)),a=this.closed(),o=n.length-i.length;p.distributePoints(o<0?n:i,Math.abs(o)),p.rotatePoints(i,n,a),this.tweenedPoints(n),yield*Q(t,r=>{const g=s(r);this.tweenedPoints(we(n,i,g))},()=>{this.tweenedPoints(null),this.points(e)})}constructor(e){super(e),this.tweenedPoints=X(null),e.children===void 0&&e.points===void 0&&Z().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre><p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre><p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>`,inspect:this.key})}childrenBBox(){let e=this.tweenedPoints();if(!e){const t=this.points();e=t?t.map(s=>new j(C(s))):this.children().filter(s=>!(s instanceof ee)||s.isLayoutRoot()).map(s=>s.position())}return se.fromPoints(...e)}parsedPoints(){return this.parsePoints(this.points())}profile(){return ye(this.tweenedPoints()??this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const e=this.radius(),t=this.lineJoin();let s=super.lineWidthCoefficient();if(e===0&&t==="miter"){const{minSin:n}=this.profile();n>0&&(s=Math.max(s,.5/n))}return s}drawOverlay(e,t){const s=this.childrenBBox().transformCorners(t),i=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(t);e.fillStyle="white",e.strokeStyle="black",e.lineWidth=1;const a=new Path2D,o=(this.tweenedPoints()??this.parsedPoints()).map(r=>r.transformAsPoint(t));if(o.length>0){te(a,o[0]);for(const r of o)ne(a,r),e.beginPath(),ae(e,r,4),e.closePath(),e.fill(),e.stroke()}e.strokeStyle="white",e.stroke(a),e.beginPath(),ie(e,i),e.stroke(),e.beginPath(),le(e,s),e.closePath(),e.stroke()}parsePoints(e){return e?e.map(t=>new j(C(t))):this.children().map(t=>t.position())}}m([E(0),U()],p.prototype,"radius",void 0);m([E(null),U()],p.prototype,"points",void 0);m([oe()],p.prototype,"tweenPoints",null);m([q()],p.prototype,"childrenBBox",null);m([q()],p.prototype,"parsedPoints",null);m([q()],p.prototype,"profile",null);let W;W??(W=new R("collisions",!1));W.loadData({version:0,shared:{background:"rgba(0,0,0,0)",range:[0,null],size:{x:1920,y:1080},audioOffset:0},preview:{fps:60,resolutionScale:1},rendering:{fps:60,resolutionScale:1,colorSpace:"srgb",exporter:{name:"@motion-canvas/core/image-sequence",options:{fileType:"image/png",quality:100,groupByScene:!1}}}});const Pe=W;let _;_??(_=new R("collisions",!1));_.loadData({version:0,timeEvents:[{name:"player scale",targetTime:0},{name:"platform scale",targetTime:.44187298170075345},{name:"player move y",targetTime:.9243451740222461},{name:"check collision",targetTime:2.0364011481880153},{name:"get velocity",targetTime:3.4207607762988395},{name:"snap back",targetTime:5.314007129916213},{name:"repeat x",targetTime:7.305195452741529},{name:"end",targetTime:13.041837298193858}],seed:3106802620});const je=_,u=re(function*(l){const e=k(),t=k(),s=k(),n=k();l.add(w(pe,{children:[w(de,{ref:t,size:[600,100],fill:"#ddd",position:[0,100],scale:0}),w(ge,{ref:e,size:100,fill:"#fff",position:[0,-100],scale:0}),w(p,{ref:s,points:[[0,-100],[0,-100]],stroke:"#24292e",lineWidth:10,arrowSize:20,lineCap:"round",opacity:0,endArrow:!0}),w(me,{ref:n,text:"Update the Y position",fontSize:60,position:[-600,-400],fill:"#fff",fontFamily:"cera pro",opacity:0})]})),yield*f("player scale"),yield*e().scale(1,.25,V),yield*f("platform scale"),yield*t().scale(1,.25,V),yield*f("player move y"),yield*n().opacity(1,.25,c),yield*e().position.y(50,.5,ce),yield*f("check collision"),yield*n().text("Check for a collision",.25,c),yield*e().fill("#f00",.25,c),yield*f("get velocity"),yield*n().text(`Get the direction
it was travelling in`,.25,c),yield*s().opacity(1,.25,c),yield*s().points([[0,-100],[0,50]],.5,c),yield*f("snap back"),yield*n().text(`Snap back in the
opposite direction`,.25,c),yield*S(e().position.y(0,.5,h),e().fill("#fff",.5,h),s().points([[0,50],[0,50]],.5,h),s().arrowSize(0,.5,h)),yield*f("repeat x"),yield*n().text("Repeat for the X axis",.25,c),yield*S(t().rotation(90,.5,M),t().position.y(0,.5,M),t().position.x(200,.5,M)),yield s().points([[0,0],[0,0]]),yield s().arrowSize(20),yield*P(.5),yield*e().position.x(150,.5,c),yield*P(.5),yield*e().fill("#f00",.25,c),yield*P(.5),yield*s().points([[0,0],[150,0]],.5,c),yield*P(.5),yield*S(e().position.x(100,.5,h),e().fill("#fff",.5,h),s().points([[150,0],[150,0]],.5,h),s().arrowSize(0,.5,h)),yield*f("end"),yield*S(e().scale(0,.25,A),t().scale(0,.25,A),n().opacity(0,.25,h)),yield*P(1)});u.name="collisions";je.attach(u.meta);u.onReplaced??(u.onReplaced=new he(u.config));const ve=fe({scenes:[u]}),$=new R("settings","\0settings");$.loadData({version:1,appearance:{color:"rgb(51,166,255)",font:!0,coordinates:!0},defaults:{background:null,size:{x:1920,y:1080}}});const Te=ue("collisions",{core:"3.12.1",two:"3.12.4",ui:"3.12.4",vitePlugin:"3.12.3"},[],ve,Pe,$);export{Te as default};
